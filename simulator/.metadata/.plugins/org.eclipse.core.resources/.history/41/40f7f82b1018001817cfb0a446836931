/***************************************************************************
 *   Copyright (C)  2018 by Polidori Paolo                                 *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   As a special exception, if other files instantiate templates or use   *
 *   macros or inline functions from this file, or you compile this file   *
 *   and link it with other works to produce a work based on this file,    *
 *   this file does not by itself cause the resulting work to be covered   *
 *   by the GNU General Public License. However the source code for this   *
 *   file must still be made available in accordance with the GNU General  *
 *   Public License. This exception does not invalidate any other reasons  *
 *   why a work based on this file might be covered by the GNU General     *
 *   Public License.                                                       *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, see <http://www.gnu.org/licenses/>   *
 ***************************************************************************/
#include "../maccontext.h"
#include "topology_context.h"
#include <stdexcept>

namespace miosix {


unsigned short TopologyContext::getBestPredecessor() {
    return (ctx.getHop() > 1)? min_element(predecessorsRSSIUnseenSince.begin(),
            predecessorsRSSIUnseenSince.end(),
            CompareRSSI(ctx.getNetworkConfig()->maxRoundsUnreliableParent
                    ))->first: 0;
}

void MeshTopologyContext::receivedMessage(unsigned char* pkt, unsigned short len, unsigned short nodeIdByTopologySlot,
        short rssi) {
    auto config = ctx.getNetworkConfig();
    if (len % NeighborMessage::getMaxSize(
            config->maxNodes, config->networkIdBits, config->hopBits))
        throw std::runtime_error("Received invalid length topology packet");
    for (auto i = 0; i < len;) {
        auto* newData = NeighborMessage::fromPkt(config->maxNodes, config->networkIdBits, config->hopBits, pkt, i);
        if (newData == nullptr) throw std::runtime_error("Wrongly checked received invalid length topology packet");
        if (i == 0 && newData->getSender() != nodeIdByTopologySlot) {
            unreceivedMessage(nodeIdByTopologySlot);
            throw std::runtime_error("Received topology packet from a node whose timeslot is different");
        }
        i += newData->getSize();
        //add it as neighbor and update last seen
        neighborsUnseenSince[newData->getSender()] = 0;
        if (newData->getHop() < ctx.getHop())
            //if it comes from the previous hop, set its RSSI for choosing the best assignee
            predecessorsRSSIUnseenSince[newData->getSender()] = std::make_pair(rssi, 0);
        if (newData->getAssignee() == config->networkId) {
            //The node chosen me for forwarding the data
            if (enqueuedTopologyMessages.hasKey(newData->getAssignee())) {
                //if i already know the node
                auto oldData = enqueuedTopologyMessages.getByKey(newData->getSender());
                //if i have old data
                if (*((NeighborMessage*) oldData.second) != *newData)
                    //if it's different, update it and reset its position in the queue
                    enqueuedTopologyMessages.update(newData->getAssignee(), 0, std::move(newData));
                else enqueuedTopologyMessages.update(newData->getAssignee(), oldData.first + 1);
            } else {//new neighbor's data
                enqueuedTopologyMessages.enqueue(newData->getAssignee(), 0, std::move(newData));
            }
        }
    }
}

void MeshTopologyContext::unreceivedMessage(unsigned short nodeIdByTopologySlot) {
    if (enqueuedTopologyMessages.hasKey(nodeIdByTopologySlot))
        enqueuedTopologyMessages.update(
                nodeIdByTopologySlot, enqueuedTopologyMessages.getByKey(nodeIdByTopologySlot).first + 1);
    auto it = neighborsUnseenSince.find(nodeIdByTopologySlot);
    if (it != neighborsUnseenSince.end())
        if (it->second >= ctx.getNetworkConfig()->maxRoundsUnavailableBecomesDead)
            neighborsUnseenSince.erase(it);
        else
            it->second++;
    auto it2 = predecessorsRSSIUnseenSince.find(nodeIdByTopologySlot);
    if (it2 != predecessorsRSSIUnseenSince.end())
        if (it2->second.second >= ctx.getNetworkConfig()->maxRoundsUnreliableParent)
            predecessorsRSSIUnseenSince.erase(it2);
        else
            it2->second.second++;
}

std::vector<TopologyMessage*> MeshTopologyContext::dequeueMessages(unsigned short count) {
    std::vector<TopologyMessage*> retval;
    auto elem = enqueuedTopologyMessages.top();
    for (unsigned short i = 0; i < count && !enqueuedTopologyMessages.isEmpty(); i++, elem = enqueuedTopologyMessages.top()) {
        retval.push_back(elem.second);
    }
    return retval;
}

TopologyMessage* MeshTopologyContext::getMyTopologyMessage() {
    auto config = ctx.getNetworkConfig();
    std::vector<bool> neighbors(config->maxNodes - 1);
    for (unsigned short i = 0; i < config->maxNodes - 1; i++)
        neighbors[i] = neighborsUnseenSince.find(i) != neighborsUnseenSince.end();
    if (ctx.getHop() == 1) neighbors[0] = true;
    return new NeighborMessage(config->maxNodes, config->networkIdBits, config->hopBits, ctx.networkId, ctx.getHop(),
            getBestPredecessor(), std::move(neighbors));
}

} /* namespace miosix */
