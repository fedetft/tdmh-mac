/***************************************************************************
 *   Copyright (C) 2012, 2013, 2014, 2015, 2016 by Terraneo Federico and   *
 *      Luigi Rinaldi                                                      *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 *   This program is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         *
 *   GNU General Public License for more details.                          *
 *                                                                         *
 *   As a special exception, if other files instantiate templates or use   *
 *   macros or inline functions from this file, or you compile this file   *
 *   and link it with other works to produce a work based on this file,    *
 *   this file does not by itself cause the resulting work to be covered   *
 *   by the GNU General Public License. However the source code for this   *
 *   file must still be made available in accordance with the GNU General  *
 *   Public License. This exception does not invalidate any other reasons  *
 *   why a work based on this file might be covered by the GNU General     *
 *   Public License.                                                       *
 *                                                                         *
 *   You should have received a copy of the GNU General Public License     *
 *   along with this program; if not, see <http://www.gnu.org/licenses/>   *
 ***************************************************************************/

#include "Transceiver.h"
#include "RadioMessage.h"
#include "omnetpp.h"
#include <cstring>
#include <algorithm>

using namespace std;

const std::string Transceiver::timeoutPktName = "TIMEOUT";

Transceiver::Transceiver(NodeBase& node) : parentNode(node), timeoutMsg(timeoutPktName.c_str(), KIND_TIMEOUT) {
}

Transceiver::~Transceiver() {
    // TODO Auto-generated destructor stub
}

void Transceiver::configure(const TransceiverConfiguration& config) {
    if(config.frequency < minFrequency || config.frequency > maxFrequency)
        throw range_error("config.frequency");
    cfg = config;
}

void Transceiver::sendNow(const void* pkt, int size, string pktName) {
    sendAt(pkt, size, simTime().inUnit(SIMTIME_NS), pktName, Unit::NS);
}

bool Transceiver::sendCca(const void* pkt, int size) {
    throw runtime_error("Unimplementable");
}

void Transceiver::sendAt(const void* pkt, int size, long long when, string pktName, Unit unit) {
    if (unit != Unit::NS) throw runtime_error("Not implemented");
    auto waitTime = SimTime(when, SIMTIME_NS) - simTime();
    if(waitTime < 0) throw runtime_error("Transceiver::sendAt too late to send");
    parentNode.waitAndDeletePackets(waitTime);

    unsigned char finalPkt[size];
    if (cfg.crc) {
        if (size > RadioMessage::dataSize - 2) throw runtime_error(string("Packet too long ")+to_string(size));
        unsigned char finalPkt[size + 2];
        memcpy(finalPkt, pkt, 0, size);
        auto crc = computeCrc(origPkt, size);
        pkt[size] = crc & 0xFF;
        pkt[size + 1] = crc >> 2;
    } else finalPkt = pkt;
    for(int i=0; i<parentNode.gateSize("wireless"); i++)
        parentNode.send(new RadioMessage(pkt, size, pktName), "wireless$o", i);

    EV_INFO << "starting to send packet " << simTime().inUnit(SIMTIME_NS) << endl;
    parentNode.waitAndDeletePackets(SimTime(RadioMessage::getPPDUDuration(size), SIMTIME_NS));
    EV_INFO << "finishing to send packet " << simTime().inUnit(SIMTIME_NS) << endl;
}

RecvResult Transceiver::recv(void* pkt, int size, long long timeout, Unit unit, Correct c) {
    if (unit != Unit::NS) throw runtime_error("Not implemented");
    if (c != Correct::CORR) throw runtime_error("Not implemented");
    RecvResult result;
    auto waitDelta = SimTime(timeout, SIMTIME_NS) - simTime();
    EV_INFO << "Awaiting packet for " << waitDelta.inUnit(SIMTIME_NS) << " (until " << timeout << ") ns" << endl;
    //parentNode.scheduleAt(SimTime(timeout, SIMTIME_NS), &timeoutMsg);
    cMessage *msg = parentNode.receive(waitDelta);
    /*if (msg->isSelfMessage() && msg->getName() == timeoutPktName.c_str() && msg->getKind() == KIND_TIMEOUT) {
        result.error = RecvResult::TIMEOUT;
        return result; //no message received
    }
    parentNode.cancelEvent(&timeoutMsg);*/
    if (msg == nullptr || !msg->isPacket()) {
        result.error = RecvResult::TIMEOUT;
        delete msg;
        return result; //no message received
    }
    auto cPkt = (cPacket*) msg;
    long long msgDataTimeNs =  cPkt->getBitLength() * 4000;
    result.timestamp = msg->getSendingTime().inUnit(SIMTIME_NS);
    result.timestampValid = true;
    if ((cfg.strictTimeout? 0 : msgDataTimeNs) + RadioMessage::preambleSfdLenTimeNs + msg->getSendingTime().inUnit(SIMTIME_NS) > timeout) {
        result.error = RecvResult::TIMEOUT;
        return result;//packet received but exceeds the timeout
    }
    cQueue interferringMsgs, collidingMsgs;
    //wait for the max confidence time to obtain a constructive interference
    EV_INFO << "Awaiting interfering packets for " << RadioMessage::constructiveInterferenceTimeNs << " (until " << simTime().inUnit(SIMTIME_NS) + RadioMessage::constructiveInterferenceTimeNs << ")" << endl;
    parentNode.waitAndEnqueue(SimTime(RadioMessage::constructiveInterferenceTimeNs, SIMTIME_NS), &interferringMsgs);
    //and wait for the whole message length
    auto msgDeadlineDelta = msgDataTimeNs + RadioMessage::preambleSfdLenTimeNs - RadioMessage::constructiveInterferenceTimeNs;
    EV_INFO << "Awaiting for the whole message to arrive for " << msgDeadlineDelta << " (until " << simTime().inUnit(SIMTIME_NS) + msgDataTimeNs + RadioMessage::preambleSfdLenTimeNs << ")" << endl;
    parentNode.waitAndEnqueue(SimTime(msgDeadlineDelta, SIMTIME_NS), &collidingMsgs);
    if (!collidingMsgs.isEmpty()) {
        //TODO add CRC fail if CRC enabled, else return random bytes array of random length
        result.error = RecvResult::CRC_FAIL;
        delete msg;
        while(!collidingMsgs.isEmpty()) delete collidingMsgs.pop();
        while(!interferringMsgs.isEmpty()) delete interferringMsgs.pop();
        return result; //message collided and arrived corrupted
    }
    result.error = RecvResult::OK;
    int corrLen = cPkt->getByteLength();
    result.size = corrLen;
    unsigned char* correlated;
    if (!interferringMsgs.isEmpty()) {
        std::vector<cPacket*> packets;
        std::list<int> lengths;
        packets.push_back(cPkt);
        lengths.push_back(corrLen);
        for (cQueue::Iterator it(interferringMsgs); !it.end(); it++){
            if (((cMessage*) *it)->isPacket()){
                packets.push_back((cPacket*) *it);
                auto len = ((cPacket*) *it)->getByteLength();
                if (len > corrLen) corrLen = len;
                lengths.push_back(len);
            }
        }
        correlated = new unsigned char[corrLen];
        //warning: supposing that if interfering, no timing offset in packet symbols is involved
        // and also it is avoided to correlate the bytes by their PN sequence.
        //Only the theoretical results of Glossy are taken into account.
        for(int i = 0; i < corrLen; i++) {
            auto numPkts = std::count_if(lengths.begin(), lengths.end(), [i](int e){return e > i;});
            auto chosenPkt = parentNode.uniform(0, numPkts, 0);
            auto actualPkt = -1;
            int j = 0;
            for (auto len = lengths.begin(); j <= chosenPkt; len++) {
                if (*len > i) j++;
                actualPkt++;
            }
            correlated[i] = static_cast<unsigned char*>(packets[actualPkt]->getContextPointer())[i];
        }
        while(!interferringMsgs.isEmpty()) delete interferringMsgs.pop();
    } else {
        correlated = new unsigned char[corrLen];
        auto* ctx = cPkt->getContextPointer();
        memcpy(correlated, ctx, corrLen);
    }
    delete msg;
    if (corrLen > size) {
        result.error = RecvResult::TOO_LONG;
    }
    memcpy(pkt, correlated, std::min(size, corrLen));
    if (size > corrLen) memset(((unsigned char*) pkt) + corrLen, 0, size - corrLen);
    return result;
}

static uint16_t Transceiver::computeCrc(const void* data, int size) {
    crcMutex.lock();
    crc.reset();
    crc.process_bytes(data, size);
    auto crc = static_cast<uint16_t>(crc.checksum());
    crcMutex.unlock();
    return crc;
}
