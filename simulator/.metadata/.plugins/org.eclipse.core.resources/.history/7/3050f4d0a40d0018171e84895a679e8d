//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
//

#include "NodeBase.h"
#include <list>
#include <vector>
#include <algorithm>
#include <cstring>

const std::string NodeBase::timeoutPktName = "TIMEOUT";

void NodeBase::waitAndDeletePackets(simtime_t timeDelta)
{
    cQueue queue;
    waitAndEnqueue(timeDelta,&queue);
    //TODO: is this efficient? And most important, why can't they use std::list?
    while(!queue.isEmpty()) delete queue.pop();
}

 RecvResult NodeBase::receive(void* packet, int size, simtime_t timeout, bool strictTimeout) {
    RecvResult result;
    auto waitDelta = timeout - simTime();
    cMessage timeoutMsg(timeoutPktName.c_str(), KIND_TIMEOUT);
    auto dio = waitDelta.inUnit(SIMTIME_NS);
    scheduleAt(timeout, &timeoutMsg);
    cQueue interferringMsgs, collidingMsgs;
    cMessage *msg = cSimpleModule::receive(waitDelta);
    cancelEvent(&timeoutMsg);
    if(msg == nullptr || !msg->isPacket() || (msg->isSelfMessage() && msg->getName() == timeoutPktName.c_str() && msg->getKind() == KIND_TIMEOUT)) {
        result.error = RecvResult::TIMEOUT;
        return result; //no message received
    }
    auto pkt = (cPacket*) msg;
    auto msgDataTimeNs =  pkt->getBitLength() * 4000;
    result.timestamp = msg->getSendingTime().inUnit(SIMTIME_NS) + msgDataTimeNs + preambleSfdTimeNs;
    result.timestampValid = true;
    if (SimTime((strictTimeout? 0 : msgDataTimeNs) + preambleSfdTimeNs, SIMTIME_NS) + msg->getSendingTime() > timeout) {
        result.error = RecvResult::TIMEOUT;
        return result;//packet received but exceeds the timeout
    }
    //wait for the max confidence time to obtain a constructive interference
    waitAndEnqueue(SimTime(constructiveInterferenceTimeNs, SIMTIME_NS), &interferringMsgs);
    //and wait for the whole message length
    waitAndEnqueue(SimTime(msgDataTimeNs + preambleSfdTimeNs - constructiveInterferenceTimeNs, SIMTIME_NS), &collidingMsgs);
    if (!collidingMsgs.isEmpty()) {
        result.error = RecvResult::CRC_FAIL;
        return result; //message collided and arrived corrupted
    }
    result.error = RecvResult::OK;
    if (interferringMsgs.isEmpty()) {
        return result; //no interferences
    }
    int corrLen = pkt->getByteLength();
    result.size = corrLen;
    std::vector<cPacket*> packets;
    std::list<int> lengths;
    for (cQueue::Iterator it(interferringMsgs); !it.end(); it++){
        if (((cMessage*) *it)->isPacket()){
            packets.push_back((cPacket*) *it);
            auto len = ((cPacket*) *it)->getByteLength();
            if (len > corrLen) corrLen = len;
            lengths.push_back(len);
        }
    }
    unsigned char* correlated = new unsigned char[corrLen];
    //warning: supposing that if interfering, no timing offset in packet symbols is involved
    // and also it is avoided to correlate the bytes by their PN sequence.
    //Only the theoretical results of Glossy are taken into account.
    for(int i = 0; i < corrLen; i++) {
        auto numPkts = std::count_if(lengths.begin(), lengths.end(), [i](int e){return e > i;});
        auto chosenPkt = uniform(0, numPkts, 0);
        auto actualPkt = -1;
        int j = 0;
        for (auto len = lengths.begin(); j <= chosenPkt; len++) {
            if (*len > i) j++;
            actualPkt++;
        }
        correlated[i] = static_cast<unsigned char*>(packets[actualPkt]->getContextPointer())[i];
    }
    if (corrLen > size) {
        result.error = RecvResult::TOO_LONG;
        return result;
    }
    memcpy(packet, correlated, std::min(size, corrLen));
    if (size > corrLen) memset(packet, 0, size - corrLen);
    return result;
}

void NodeBase::sendAt(void* packet, int size, simtime_t when, std::string pktName) {
    waitAndDeletePackets(when - SimTime());
    cPacket* pkt;
    for(int i=0; i<gateSize("wireless"); i++){
        pkt = new cPacket(pktName.c_str());
        pkt->setByteLength(size);
        void* data = new unsigned char[size];
        memcpy(data, packet, size);
        pkt->setContextPointer(data);
        send(pkt, "wireless$o",i);
    }
    waitAndDeletePackets(SimTime(pkt->getBitLength() * 4, SIMTIME_US));
}
